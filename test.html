<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      class TvDatafeed {
        constructor(username = null, password = null) {
          this.token = this._auth(username, password);
          this.session = this._generateSession();
          this.chartSession = this._generateChartSession();
          this.ws = null;
        }

        async _auth(username, password) {
          if (username === null || password === null) {
            console.warn(
              "You are using nologin method, data you access may be limited"
            );
            return "unauthorized_user_token";
          }

          const data = {
            username: username,
            password: password,
            remember: "on",
          };

          try {
            const response = await fetch(
              "https://www.tradingview.com/accounts/signin/",
              {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  Referer: "https://www.tradingview.com",
                },
                body: JSON.stringify(data),
              }
            );
            const jsonResponse = await response.json();
            return jsonResponse.user.auth_token;
          } catch (error) {
            console.error("Error while signing in:", error);
            return "unauthorized_user_token";
          }
        }

        _generateSession() {
          return "qs_" + Math.random().toString(36).substring(2, 14);
        }

        _generateChartSession() {
          return "cs_" + Math.random().toString(36).substring(2, 14);
        }

        _formatSymbol(symbol, exchange, contract = null) {
          if (symbol.includes(":")) {
            return symbol;
          } else if (contract === null) {
            return `${exchange}:${symbol}`;
          } else if (Number.isInteger(contract)) {
            return `${exchange}:${symbol}${contract}!`;
          } else {
            throw new Error("Not a valid contract");
          }
        }

        _createConnection() {
          return new Promise((resolve, reject) => {
            this.ws = new WebSocket(
              "wss://data.tradingview.com/socket.io/websocket"
            );
            this.ws.onopen = () => resolve();
            this.ws.onerror = (error) => reject(error);
          });
        }

        _sendMessage(func, args) {
          const message = this._createMessage(func, args);
          this.ws.send(message);
        }

        _createMessage(func, paramList) {
          const message = JSON.stringify({ m: func, p: paramList });
          return `~m~${message.length}~m~${message}`;
        }

        async getHist(
          symbol,
          exchange = "NSE",
          interval = "D",
          nBars = 10,
          futContract = null,
          extendedSession = false
        ) {
          symbol = this._formatSymbol(symbol, exchange, futContract);

          await this._createConnection();

          this._sendMessage("set_auth_token", [this.token]);
          this._sendMessage("chart_create_session", [this.chartSession, ""]);
          this._sendMessage("quote_create_session", [this.session]);
          this._sendMessage("quote_set_fields", [
            this.session,
            "ch",
            "chp",
            "current_session",
            "description",
            "local_description",
            "language",
            "exchange",
            "fractional",
            "is_tradable",
            "lp",
            "lp_time",
            "minmov",
            "minmove2",
            "original_name",
            "pricescale",
            "pro_name",
            "short_name",
            "type",
            "update_mode",
            "volume",
            "currency_code",
            "rchp",
            "rtc",
          ]);

          this._sendMessage("quote_add_symbols", [
            this.session,
            symbol,
            { flags: ["force_permission"] },
          ]);
          this._sendMessage("quote_fast_symbols", [this.session, symbol]);

          const sessionType = extendedSession ? "extended" : "regular";
          this._sendMessage("resolve_symbol", [
            this.chartSession,
            "symbol_1",
            `={"symbol":"${symbol}","adjustment":"splits","session":"${sessionType}"}`,
          ]);
          this._sendMessage("create_series", [
            this.chartSession,
            "s1",
            "s1",
            "symbol_1",
            interval,
            nBars,
          ]);
          this._sendMessage("switch_timezone", [this.chartSession, "exchange"]);

          console.log(`Getting data for ${symbol}...`);

          return new Promise((resolve, reject) => {
            let rawData = "";

            this.ws.onmessage = (event) => {
              rawData += event.data + "\n";
              if (event.data.includes("series_completed")) {
                this.ws.close();
                resolve(this._createDataFrame(rawData, symbol));
              }
            };

            this.ws.onerror = (error) => {
              console.error("WebSocket error:", error);
              reject(error);
            };
          });
        }

        _createDataFrame(rawData, symbol) {
          // This is a simplified version. You might need to adjust the parsing logic
          // to match the exact format of the received data.
          const dataRegex = /"s":\[(.+?)\}\]/;
          const match = rawData.match(dataRegex);

          if (!match) {
            console.error("No data found in the response");
            return null;
          }

          const dataString = match[1];
          const dataPoints = dataString.split('},{"');

          return dataPoints.map((point) => {
            const values = point.split(/[\[:\],{}]/);
            return {
              datetime: new Date(parseFloat(values[4]) * 1000),
              symbol: symbol,
              open: parseFloat(values[5]),
              high: parseFloat(values[6]),
              low: parseFloat(values[7]),
              close: parseFloat(values[8]),
              volume: parseFloat(values[9]) || 0,
            };
          });
        }
      }
      const tv = new TvDatafeed();
      tv.getHist("AAPL", "NASDAQ", "D", 10)
        .then((data) => console.log(data))
        .catch((error) => console.error(error));
    </script>
  </body>
</html>
